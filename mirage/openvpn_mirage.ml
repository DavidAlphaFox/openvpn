(* An OpenVPN layer for MirageOS. Given a stackv4 and a configuration, it
   connects to the OpenVPN gateway in tun mode. Once the tunnel is established,
   an IPv4 stack is returned. *)

(* This effectful OpenVPN client layer is mostly reactive - only when some
   event occured, such as receiving data from the tunnel, a read failure
   (which immediately closes the connection), or a timer `Tick (once every
   second), or an user wants to transmit data (write) over the tunnel, work
   will be done.

   The asynchronous task library lwt is in use here, which provides cooperative
   tasks -- not preemptive tasks! This means that only at yield points
   (Lwt.bind (>>=) and Lwt.map (>|=)) other tasks can be scheduled. Everything
   between two yield points will happen atomically!

   Speaking of tasks, there are three tasks involved:
   - reader -- which is reading from a given TCP flow (started once
               TCP.create_connection successfully established a connection)
   - timer -- which sleeps for a second, produces a `Tick, in a loop
   - event -- which waits for events (generated by reader and timer), calling
              Openvpn.handle for each event, and executing potential actions
              asynchronously (via Lwt.async handle_action)

   Synchronisation is achieved by Lwt_mvar.t variables, there are two:
   * data_mvar which gets put when payload has been received over the
               tunnel (it is taken by process_data)
   * est_mvar which gets put once the tunnel is established. connect takes
              that before returning (subsequent put mutate t)
   * event_mvar which gets put by timer/reader/handle_action whenever an
                event occured, the event task above waits for it *)

(* TODO to avoid deadlocks, better be sure that
   (a) until connect returns there ain't any data_mvar put happening -- since
       only the task returned by connect (process_data) calls Lwt_mvar.take --
       to-be-called by the client of this stack *)

open Lwt.Infix

let src = Logs.Src.create "openvpn.mirage" ~doc:"OpenVPN MirageOS layer"
module Log = (val Logs.src_log src : Logs.LOG)

module Make (R : Mirage_random.C) (M : Mirage_clock.MCLOCK) (P : Mirage_clock.PCLOCK) (T : Mirage_time_lwt.S) (S : Mirage_stack_lwt.V4) = struct
  (* boilerplate i don't understand *)
  type 'a io = 'a Lwt.t
  type buffer = Cstruct.t
  type ipaddr = Ipaddr.V4.t
  type callback = src:ipaddr -> dst:ipaddr -> buffer -> unit Lwt.t
  let pp_ipaddr = Ipaddr.V4.pp

  type error = [ Mirage_protocols.Ip.error
               | `Msg of string
               | `Would_fragment
               | `Openvpn of Openvpn.error ]
  let pp_error ppf = function
    | #Mirage_protocols.Ip.error as e -> Mirage_protocols.Ip.pp_error ppf e
    | `Msg m -> Fmt.pf ppf "message %s" m
    | `Would_fragment -> Fmt.string ppf "would fragment, but fragmentation is disabled"
    | `Openvpn e -> Openvpn.pp_error ppf e

  module DNS = Dns_mirage_client.Make(S)
  module TCP = S.TCPV4

  type conn = {
    mutable o_client : Openvpn.t ;
    mutable tcp_flow : TCP.flow option ;
    data_mvar : Cstruct.t list Lwt_mvar.t ;
    est_mvar : (Openvpn.ip_config * int) Lwt_mvar.t ;
    event_mvar : Openvpn.event Lwt_mvar.t ;
  }

  type t = {
    conn : conn ;
    mutable ip_config : Openvpn.ip_config ;
    mutable mtu : int ;
    mutable frags : Fragments.Cache.t ;
  }

  let now () = Ptime.v (P.now_d_ps ())
  let ts () = M.elapsed_ns ()

  let get_ip t = t.ip_config.Openvpn.ip

  let mtu t = t.mtu

  let transmit flow data =
    match flow, data with
    | _, [] -> Lwt.return true
    | None, _ ->
      Log.err (fun m -> m "no flow, cannot transmit");
      Lwt.return false
    | Some f, _ ->
      TCP.writev f data >|= function
      | Ok () -> true
      | Error e ->
        Log.err (fun m -> m "tcp write failed %a" TCP.pp_write_error e);
        false

  let encode_encrypt c hdr data =
    let payload_len = Cstruct.len data
    and hdr_buf = Cstruct.create Ipv4_wire.sizeof_ipv4
    in
    match Ipv4_packet.Marshal.into_cstruct ~payload_len hdr hdr_buf with
    | Error msg ->
      Log.err (fun m -> m "failure while assembling ip frame: %s" msg) ;
      assert false
    | Ok () ->
      Ipv4_common.set_checksum hdr_buf;
      match Openvpn.outgoing c (ts ()) (Cstruct.append hdr_buf data) with
      | Error `Not_ready ->
        Log.warn (fun m -> m "tunnel not ready, dropping data!");
        c, None
      | Ok (c', out) -> c', Some out

  let write t ?(fragment = true) ?(ttl = 38) ?src dst proto ?(size = 0) headerf bufs =
    (* everything must be unfragmented! the Openvpn.outgoing function prepends *)
    (* whatever we get here we may need to split up *)
    Log.debug (fun m -> m "write size %d bufs len %d" size (Cstruct.lenv bufs));
    (* no options here, always 20 bytes IPv4 header size! *)
    (* first figure out the actual payload a user wants *)
    let u_hdr =
      if size > 0 then
        let b = Cstruct.create size in
        let l = headerf b in
        Cstruct.sub b 0 l
      else
        Cstruct.empty
    in
    let payload = Cstruct.concat (u_hdr :: bufs) in
    let pay_len = Cstruct.len payload in
    let hdr =
      let src = match src with None -> get_ip t | Some x -> x in
      let off = if fragment then 0x0000 else 0x4000 in
      Ipv4_packet.{
        options = Cstruct.empty ;
        src ; dst ;
        ttl ; off ; id = 0 ;
        proto = Ipv4_packet.Marshal.protocol_to_int proto }
    in
    (* now we take chunks of (mtu - hdr_len) one at a time *)
    let ip_payload_len = mtu t - Ipv4_wire.sizeof_ipv4 in
    assert (ip_payload_len > 0);
    if not fragment && ip_payload_len < pay_len then
      invalid_arg "don't fragment set, but too much payload!"
    else
      let c', outs =
        if pay_len <= ip_payload_len then
          (* simple case, marshal and go ahead *)
          let c', out = encode_encrypt t.conn.o_client hdr payload in
          c', match out with None -> [] | Some o -> [ o ]
        else
          (* complex case: loop, set more_fragments and offset *)
          (* set an ip ID *)
          (* we also need to ensure that our v4 payload is 8byte-bounded *)
          (*  ~~> since we're at max, we may need to reduce mtu again... *)
          let ip_payload_len' = ip_payload_len - (ip_payload_len mod 8) in
          let frags = (pay_len + pred ip_payload_len') / ip_payload_len' in
          (* do not set more_fragments in last one *)
          let hdr = { hdr with id = Randomconv.int16 R.generate } in
          let c', outs =
            List.fold_left (fun (c, outs) idx ->
                let start = idx * ip_payload_len' in
                let off =
                  (if idx = pred frags then 0 else 0x2000) (* more frags *) +
                  (start / 8)
                in
                let hdr' = { hdr with off } in
                let data =
                  let len = min ip_payload_len' (Cstruct.len payload - start) in
                  Cstruct.sub payload start len
                in
                let c', out = encode_encrypt c hdr' data in
                let out' = match out with None -> outs | Some x -> x :: outs in
                c', out')
              (t.conn.o_client, []) (List.init frags (fun i -> i))
          in
          c', List.rev outs
      in
      t.conn.o_client <- c';
      transmit t.conn.tcp_flow outs >|= fun r ->
      if r then Ok () else Error (`Msg "write failed")

  let input t ~tcp ~udp ~default buf =
    match Ipv4_packet.Unmarshal.of_cstruct buf with
    | Error s ->
      Log.err (fun m -> m "error %s while parsing IPv4 frame %a" s Cstruct.hexdump_pp buf);
      Lwt.return_unit
    | Ok (packet, payload) ->
      Log.info (fun m -> m "received IPv4 frame: %a (payload %d bytes)"
                   Ipv4_packet.pp packet (Cstruct.len payload));
      let frags, r = Fragments.process t.frags (ts ()) packet payload in
      t.frags <- frags;
      match r with
      | None -> Lwt.return_unit
      | Some (pkt, payload) ->
        let src, dst = pkt.src, pkt.dst in
        match Ipv4_packet.Unmarshal.int_to_protocol pkt.proto with
        | Some `TCP -> tcp ~src ~dst payload
        | Some `UDP -> udp ~src ~dst payload
        | Some `ICMP | None -> default ~proto:pkt.proto ~src ~dst payload

  let rec process_data ~tcp ~udp ~default t =
    Log.info (fun m -> m "processing data");
    Lwt_mvar.take t.conn.data_mvar >>= fun datas ->
    Log.info (fun m -> m "now for real processing data");
    Lwt_list.iter_s (input t ~tcp ~udp ~default) datas >>= fun () ->
    process_data ~tcp ~udp ~default t

  let resolve_hostname s name =
    let res = DNS.create s in
    DNS.gethostbyname res name >|= function
    | Ok ip -> Some (Ipaddr.V4 ip)
    | Error (`Msg msg) ->
      Log.err (fun m -> m "failed to resolve %a: %s" Domain_name.pp name msg);
      None

  let connect_tcp s (ip, port) =
    match ip with
    | Ipaddr.V6 _ ->
      Log.err (fun m -> m "IPv6 not yet supported");
      Lwt.return None
    | Ipaddr.V4 ip' ->
      TCP.create_connection (S.tcpv4 s) (ip', port) >|= function
      | Ok flow -> Some flow
      | Error tcp_err ->
        Log.err (fun m -> m "failed to connect to %a:%d: %a"
                    Ipaddr.V4.pp ip' port TCP.pp_error tcp_err);
        None

  let read_flow flow =
    TCP.read flow >|= fun r ->
    match r with
    | Ok `Data b -> `Data b
    | Ok `Eof -> Log.err (fun m -> m "eof while reading"); `Connection_failed
    | Error e -> Log.err (fun m -> m "tcp read error %a" TCP.pp_error e); `Connection_failed

  let rec reader c flow =
    Log.info (fun m -> m "reading flow");
    read_flow flow >>= fun r ->
    Log.info (fun m -> m "read flow");
    Lwt_mvar.put c r >>= fun () ->
    match r with
    | `Data _ -> reader c flow
    | _ ->
      Log.err (fun m -> m "connection failed, terminating reader");
      Lwt.return_unit

  let handle_action s conn = function
    | `Resolve name ->
      (resolve_hostname s name >>= fun r ->
       let ev = match r with None -> `Resolve_failed | Some x -> `Resolved x in
       Lwt_mvar.put conn.event_mvar ev)
    | `Connect endp ->
      (connect_tcp s endp >>= fun r ->
       let ev = match r with
         | None -> `Connection_failed
         | Some flow ->
           Lwt.async (fun () -> reader conn.event_mvar flow);
           conn.tcp_flow <- Some flow;
           `Connected
       in
       Log.debug (fun m -> m "here...");
       Lwt_mvar.put conn.event_mvar ev)
    | `Disconnect ->
      (* TODO not sure, should maybe signal successful close (to be able to initiate new connection) *)
      begin match conn.tcp_flow with
        | None -> Log.err (fun m -> m "cannot disconnect no flow"); Lwt.return_unit
        | Some f -> conn.tcp_flow <- None ; TCP.close f
      end
    | `Transmit data ->
      (transmit conn.tcp_flow data >>= function
        | true -> Lwt.return_unit
        | false -> Lwt_mvar.put conn.event_mvar `Connection_failed)
    | `Exit -> Lwt.fail_with "exit called"
    | `Payload data -> Lwt_mvar.put conn.data_mvar data
    | `Established (ip, mtu) -> Lwt_mvar.put conn.est_mvar (ip, mtu)

  let rec event s conn =
    Log.info (fun m -> m "processing event");
    Lwt_mvar.take conn.event_mvar >>= fun ev ->
    Log.info (fun m -> m "now for real processing event %a" Openvpn.pp_event ev);
    match Openvpn.handle conn.o_client (now ()) (ts ()) ev with
    | Error e ->
      Log.err (fun m -> m "openvpn handle failed %a" Openvpn.pp_error e);
      Lwt.return_unit
    | Ok (t', action) ->
      conn.o_client <- t';
      Log.info (fun m -> m "handling action %a" Openvpn.pp_action action);
      Lwt.async (fun () -> handle_action s conn action);
      event s conn

  (* what we actually want to do here (and lifetimes):
     - create a Openvpn.t (Openvpn.client!)
     - execute action followed by handle
     - rinse, repeat until action is actually established
     --> when this is the case, construct a t and return

     -- the timer/tick needs to be started
     -- actions may then need to include `Read as well
     --> but "read" is required once the flow is established anyways
       --> we need to block (connect) until that read / handle put us into a good state
     --> once that is the case, we can spawn an async task for reading and return from connect!? *)
  let connect config s =
    match Openvpn.client config (ts ()) R.generate with
    | Error `Msg msg ->
      Log.err (fun m -> m "client construction failed %s" msg);
      Lwt.return (Error (`Msg msg))
    | Ok (o_client, action) ->
      let data_mvar = Lwt_mvar.create_empty ()
      and est_mvar = Lwt_mvar.create_empty ()
      and event_mvar = Lwt_mvar.create_empty ()
      in
      let conn = { o_client ; tcp_flow = None ; data_mvar ; est_mvar ; event_mvar } in
      (* handle initial action *)
      Lwt.async (fun () -> event s conn);
      let rec tick () =
        T.sleep_ns (Duration.of_sec 1) >>= fun () ->
        Lwt_mvar.put event_mvar `Tick >>= fun () ->
        tick ()
      in
      Lwt.async tick;
      handle_action s conn action >>= fun () ->
      Log.info (fun m -> m "waiting for established");
      Lwt_mvar.take est_mvar >|= fun (ip_config, mtu) ->
      Log.info (fun m -> m "now established %a (mtu %d)"
                   Openvpn.pp_ip_config ip_config mtu);
      let frags = Fragments.Cache.empty (1024 * 256) in
      let t = { conn ; ip_config ; frags ; mtu } in
      let rec established () =
        Lwt_mvar.take est_mvar >>= fun (ip_config', mtu') ->
        let ip_changed = Ipaddr.V4.compare ip_config.ip ip_config'.ip <> 0 in
        Log.info (fun m -> m "tunnel re-established (ip changed? %B) %a (mtu %d)"
                     ip_changed Openvpn.pp_ip_config ip_config' mtu');
        if ip_changed then begin
          t.frags <- Fragments.Cache.empty (1024 * 256);
          t.ip_config <- ip_config'
        end;
        (* not sure about mtu changes, but better to update this in any case *)
        t.mtu <- mtu';
        established ()
      in
      Lwt.async established;
      Ok (t, process_data)

  let disconnect _ =
    Log.warn (fun m -> m "disconnect called, should I do something?");
    Lwt.return_unit

  let set_ip _ _ =
    Log.warn (fun m -> m "set ip not supported by OpenVPN");
    Lwt.return_unit

  let pseudoheader t ?src dst proto len =
    let src = match src with
      | Some x -> x
      | None -> get_ip t
    in
    Ipv4_packet.Marshal.pseudoheader ~src ~dst ~proto len

  let src t ~dst:_ = get_ip t

  let get_ip t = [ get_ip t ]
end
